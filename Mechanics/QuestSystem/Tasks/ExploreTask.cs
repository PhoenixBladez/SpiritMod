using Microsoft.Xna.Framework;
using SpiritMod.Utilities;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Terraria;
using Terraria.ID;

namespace SpiritMod.Mechanics.QuestSystem
{
	public class ExploreTask : QuestTask
	{
		public override string ModCallName => "Explore";

		private Func<Player, bool> _exploreFunc;
		private float _requiredDistance;
		private float _distancedTravelled;
		private float _storedDistance;
		private string _areaName;

		public ExploreTask() { }

		/// <param name="areaName">Will be used for the objectives like so: - Explore [areaName] (x%)</param>
		public ExploreTask(Func<Player, bool> exploreFunction, float travelDistance, string areaName)
		{
			_exploreFunc = exploreFunction;
			_requiredDistance = travelDistance;
			_areaName = areaName;
		}

		public override QuestTask Parse(object[] args)
		{
			// get the func
			if (!QuestUtils.TryUnbox(args[1], out Func<Player, bool> func, "Explore function"))
			{
				return null;
			}

			// get the distance
			if (!QuestUtils.TryUnbox(args[2], out float distance, "Distance"))
			{
				return null;
			}

			// get the area's name
			if (!QuestUtils.TryUnbox(args[3], out string name, "Area name"))
			{
				return null;
			}

			return new ExploreTask(func, distance, name);
		}

		public override void AutogeneratedBookText(List<string> lines)
		{
			lines.Add(GetObjectives(false));
		}

		public override void AutogeneratedHUDText(List<string> lines)
		{
			lines.Add(GetObjectives(true));
		}

		public string GetObjectives(bool showProgress)
		{
			StringBuilder builder = new StringBuilder();

			builder.Append("Explore ");
			builder.Append(_areaName);

			// add a progress bracket at the end like: (x%)
			if (showProgress)
			{
				float travelled = _distancedTravelled > _requiredDistance ? _requiredDistance : _distancedTravelled;
				float progress = travelled / _requiredDistance * 100f;
				builder.Append(" [c/97E2E2:(").Append(progress.ToString("N2")).Append("%").Append(")]");
			}

			return builder.ToString();
		}

		public override void ResetProgress()
		{
			base.ResetProgress();

			_distancedTravelled = 0f;
			_storedDistance = 0f;
		}

		public override bool CheckCompletion()
		{
			if (!Main.dedServ && _exploreFunc(Main.LocalPlayer))
			{
				float distanceMoved = Main.LocalPlayer.velocity.Length();

				switch (Main.netMode)
				{
					case NetmodeID.SinglePlayer:
						_distancedTravelled += distanceMoved;
						break;
					case NetmodeID.MultiplayerClient:
						_distancedTravelled += distanceMoved;
						break;
				}
			}
			return _distancedTravelled >= _requiredDistance;
		}

		public override void OnMPSyncTick()
		{
			// TODO: send the server our stored distance, then reset to 0
			_storedDistance = 0;
		}

		public override void ReadData(BinaryReader reader)
		{
			_distancedTravelled = reader.ReadSingle();
		}

		public override void WriteData(BinaryWriter writer)
		{
			writer.Write(_distancedTravelled);
		}
	}
}
